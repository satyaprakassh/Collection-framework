/*

COLLECTION FRAMEWORK
--------------------



Limitations of Arrays :
-----------------------

(1) Arrays Are fixed in size :
- Once we declare an array with some size, after then we can't increase or decrease
that size on requirement. So to use array, we should compulsory know the size in 
advance.

ex: int [] i=new int[5];
    i[6]=12;// error. ArrayIndexOutOfBoundsException;

(2) Can hold only homogeneous elements :
- Once we declare an array of certain type then that array can only contain the same
type of elements. If we try to put any other type of elements to that array than we 
will get compile time error.

ex: Student [] s=new Student[5];
    s[0]=new Student();// valid
    s[3]=new Integer(10);//  invalid
    s4[]="sdfs";// invalid
    
                            - But there is one exception where an array can hold
heterogeneous elements using Object class as array_type.

ex:   Object [] o=new Object[10];
        o[0]=new Student();// valid
        o[3]=new Test();// valid
        o[5]="kkkkkkk";// valid


(3) doesn't support inbuilt methods :
- Arrays hsvan't any inbuilt method support. So for every time, we have to provide 
the required logics, which may increase the complexity of the programs and decrease
the performance.

- To overcome the above mentioned issues we should go for Collection framework.
*/

class IssuesWithArrays
{
    public static void main (String[] args)
    {
        String [] arr=new String[5];
        System.out.println(arr);
        arr[4]="45";
        System.out.println(arr[4]);
        arr=new String[6];//here we creating another array but not increasing its size
        System.out.println(arr);
        System.out.println(arr[3]);
    }
}

/*

Advantages of Collection over arrays :

(1) Growable in nature:
- Collections are Growable in nature i.e based on requirement we can incease or decrease
the size.

(2) Can hold both homogeneous & heterogeneous elements:

(3) Supports inbuilts methods:
-Every Collections class is implemented based on some standard data structure. Hence
for every requirment, readymade method support is available.


-note-

- performance wise Arrays are better than Collections.
- Arrays can hold both primitives and objects but Collections can hold only objects.




Collection framework:
---------------------

- It is a framework which contains several predefined classes and interfaces which
are used to represent a group of individual objects as a single entity.



9 key interfaces of Collection framework:
-----------------------------------------

(1) Collection

(2) List

(3) Set

(4) SortedSet

(5) NavigableSet

(6) Queue

(7) Map

(8) SortedMap

(9) NavigableMap


Brief introduction of the above interfaces:
-------------------------------------------
(1) Collection interface : This interface contains the most common methods which are
applicable for any Collection object. In general, Collection interface is considered
as the root interface of Collection framework.

Difference between Collection and Collections :   Collection is an interface whereas
Collections is a class present inside java.util package.



(2) List interface : It is the child interface of Collection  interface.

-    In which circumstances should we use List : If we want to represent a group of 
individual objects as a single entity where duplicates are allowed & insertion order
must be preserved then we should go for List.

- List interface has following utility classes :
- ArrayList
- LinkedList
- Vector
- Stack


(3) Set interface:  It is the direct child interface of Collection.

-   In which circumstances should we use Set : If we want to represent a group of
individual objects as a single entity where duplicates aren't allowed and insertion
order isn't required then we should go for Set interface.

- Set has following utility classes :
-HashSet
-LinkedHashSet



(4) SortedSet interface : It is the direct child interface of Set interface.

-   In which circumstances should we use Set : If we want to represent a group of
individual objects as a single entity where duplicates aren't allowed but all objects
must be inserted according to specific sorting order then we should go for SortedSet
interface.

- It has no direct child class.


(5) NavigableSet : It is the direct child interface of SortedSet. It contans several
methods for navigable purposes.

- It has a child class :   TreeSet




Queue interface : It is the child interface of Collection .

-   In which circumstances should we use Set : If we want to represent a group of
objects prior to processing then we should go for Queue interface.

- Usually, Queue follows FIFO algorithm but based on our requirement, we can implement
our own priority order also.

ex: Before sending mails, all mail-ids should be stored in some data structure. The
order in which we add the mail-ids, in the same order messeges are sent. In such 
circumstances Queue is best choice to use.

- The following are the implementation classes :

- PriorityQueue
- BlockingQueue
- PriorityBlockingQueue
- LinkedBlockingQueue
etc etc.

-note-

- All the interfaces from (1-6) are meant for representinng a group of individual 
objects.
- If we want to represent a group of objects as key-value pairs then we should go
for Map(7-9).




(7) Map interface : Map isn't the child interface of Collection.

In which circumstances we should use Map : If we want to reprent a group of objects
as key-value pairs then we should go for Map.

- Both key & value are objects only. Duplicate keys aren't allowed but values can be
Duplicated.


- The following are the implementation classes :

- HashMap
- LinkedHashMap
- WeakHashMap
- IdentityHashMap
- Dictonary
- Hashtable
- Properties



(8) SortedMap interface :  It is the child interface of Map.

- In which circumstances we should use Map : If we want to reprent a group of objects
as key-value pairs according to some sortinng order of keys then we should go for 
Map.

-note- 

- In SortedMap, the Sirting should be based on keys but not on values.



(9)NavigableMap : It is the child interface of SortedMap. It defines several methods
for navigable purposes.

- It has a implemetation class : TreeMap 
*/
import java.util.*;
class CollectionConcepts
{
     /*properties of ArrayList:
     --------------------------
        - It is resizable ie unlike Arrays, we can increase and decrease the size of
        the list.
        - duplicate objects are allowed to be stored.
        - Insertion order is preserved.
        */
         /*constructors :
        ----------------
        (1) ArrayList al=new ArrayList() : creates an deault AL object with initial
        capacity 10. When it reaches its maximum capacity then a new object is created
        with new capacity= previous capacity*(3/2) +  1   and the previous object is
        destroyed(goes to garbage collection).
        */
        /*
        public static void ALConstrucotr1()
        {
            ArrayList al1=new ArrayList();
            System.out.println(al1.size());//o|p : 0  ,but why not showing 10 as size ?
            al1.add(10);
            System.out.println(al1.size());
            System.out.println(al1);
            al1.add("rrr");
            al1.remove(0);
            System.out.println(al1);
        }
         /*
        (2)ArrayList al=new ArrayList(int capacity) : creates an AL object with some
        initial capacity.
         *//*
         public static void ALConstrucotr2()
         {
             ArrayList al2=new ArrayList(10);
             System.out.println(al2.size());// 1
             for(int i=0;i<=9;i++)
             {
                 al2.add(i);
             }
             al2.add(20);
             al2.remove(5);
             System.out.println(al2.size());// 11
             System.out.println(al2);
          }
           /*
         (3) ArrayList al=new ArrayList(collection c) : creates an AL object for any
         Collection object ie this constructor is used for interconversion of any 
         Collection object to AL object.
         *//*
         public static void ALConstrucotr3()
         {
             Vector v1=new Vector();
             v1.addElement("zzz");
             v1.addElement("hhh");
             ArrayList al3=new ArrayList(v1);
             System.out.println(al3.size());
             System.out.println(al3);
          }
        /*Properties of LinkedList :
        ----------------------------
        - It supports double LinkedList.
        - duplicates are allowed.
        - Insertion order is preserved.
        -It implements Serializable and Cloneable interface but not RandomAccess.
        */
        /*constructors :
        (1) LinkedList ll=new LinkedList() : creates an empty LL object.
        (2) LinkedList l=new LinkedList(Collection c) : interconversion of any collection obj
        to LL object.
        *//*
        static void operateOnLL()
        {
            LinkedList l=new LinkedList();
            l.add(50);
            l.add("t");
            l.add(null);
            l.removeFirst();
            l.set(2,"k");
            System.out.println(l);
        }
        /*properties of Vector :
        ------------------------
        - resizable in nature.
        - Insertion order is preserved.
        - duplicates are allowed.
        - It implements Serializable, Cloneable and also RandomAccess interface.
        - Every method of Vactor class is synchronized. So Vactor objects are thread safe.
        */
        /*constructors:
        ---------------
        (1) Vector v=new Vector(int initial capacity) 
        (2) Vector v=new Vector(int initial capacity,int incremental_capacity) : creates a
        Vector obj with some initial capacity. When it reches its maximum capacity then its
        its capacity is increased by the provied value. If it again reaches its maximum 
        capacity then it further increases its capacity and so on.
        (3) Vector v=new Vector(collection c) : used for interconversion.
        *//*
        static void Vconstructor2()
        {
            Vector v1=new Vector(5,2);
            System.out.println(v1.capacity());
            for(int i=1;i<=5;i++)
            {
                v.add(i);
            }
            v.add("hhh");
            v.add("shs");
            v.add("mmm");
            System.out.println(v1.capacity());
        }
        /*
        Cursors of java : If we want to get objects one by one from the Collection then Cursors
        are used. There are 3 types of cursors.
        
        (1) Enumeration : Used to get the objects of Legacy Collection classes like Vector.
        
        How to create Enumeration object : by using element() method.
        syntax : public Enumeration elements()*//*
        public static void enumeration()
        {
            Vector v=new Vector();
            for(int i=10;i<=100;i++)
            {
                if(i%10==0)
                {
                    v.addElement(i);
                }
            }
            System.out.println(v);
            
            Enumeration e=v.elements();
            while(e.hasMoreElement())
            {
                Integer i=(Integer)e.nextElement();
                if(i%20==0)
                {
                    System.out.println(i+" ");
                }
            }
            System.out.println(v);
        }
        /*
        disadvantages of Enumeration : we can apply Enumeration objects only for legacy classes
        - we can get only read access , can't perform remove operations.
        
        To overcome theh above problems we should use Iteration*/
        /*(2) Iteration :  
        - This is universal cursor object so we can apply to any Collection
        object.
        - We can perform both read & remove operations.
        
        How to get Iterator object : by using iterator() method
        syntax : public Iterator iterator()
        */
        public static void getIteratorObj()
        {
            ArrayList <String>al=new ArrayList<String>();
            al.add("a");
            al.add("b");
            al.add("c");
            al.add("d");
            Iterator i=al.iterator();
            Object obj=i.next();
            i.remove();
            System.out.println(obj);
            System.out.println(al);
        }
    public static void main (String[] args)
    
    {
        CollectionConcepts.getIteratorObj();
    }
}
import java.util.*;
class CursorsOfJava
{
    /*
    (3) ListIterator :
    - It is child Interface of Iterator.
    - It is applicable only for List objects.
    - It can move towards both forward and backward directions.
    - It is used to perform the following operatiions :
    (1)read  (2)remove  (3) replacement  (4) addition of new elements
    
    syntax :   public ListIterator listIterator();
    
    How to get ListIterator Object : ListIterator li=l.listIterator(), where l : any List object.
    */
    public static void performLIFunctions()
    {
        ArrayList<String> al=new ArrayList<String>();
        al.add("a");
        al.add("b");
        al.add("c");
        al.add("10");
        System.out.println(al);
        ListIterator li=al.listIterator();
        System.out.println(li.hasPrevious());
        while(li.hasNext())
        {
            //System.out.println(li.previous());
            String str=(String)li.next();
            //System.out.println(str);
           
            if(str.equals("10"))
            {
                li.set("100");
            }
             else if(str.equals("c"))
            {
                li.add("ccc");
            }
            else if(str.equals("a"))
            {
                li.remove();
            }
        }
        while(li.hasPrevious()==true)
        {
            System.out.println(li.previous());
        }
        System.out.println(al);
    }
    public static void main (String[] args) {
        CursorsOfJava.performLIFunctions();
    }
}
import java.util.*;
class SetConcepts
{
    /*Set :
    -------
    - If we want to represent a group of elements as a single entity where duplicates are not
    allowed and insertion order isn't preserved then we should go for Set.
    */
    /*
    HashSet class :
    - duplicates not allowed.
    - Heteorgenous objects allowed.
    - Insertion order isn't preserved because objects are inserted based on hashcode.
    - It implements Serializable, Cloneable but not RandomAccess.
    
    note: if we add duplicate elements to HashSet object then we won't get any compile time or
    runtime errors rather the add() method  will simply return false i.e the duplicate element
    will not be added.
    */

    public static void aboutHashSetClass()
    {
        HashSet hs=new HashSet(6,0.5f);// 1st arg :initial capacity &   2nd arg:filled ratio
        /*filled ratio is the range until which the objs are inserted. For the above constructor
        //3 elements can be filled and after crossing this range , a new obj will be created.*/
        
        System.out.println(hs.size());// instead of 3 , the result shows 0. why ???
        
        hs.add("A");
        hs.add("B");
        hs.add(10);
        hs.add(null);
        hs.add(true);
        hs.add(20);
        hs.add("C");
        hs.add("D");
        hs.add("E");
        hs.add("A");
        System.out.println(hs);// we can't expect the exact output because objs are inserted
        //based on hashcode.
        
    }
    /*
    LinkedHashSet class : It is almost same as HashSet class. But it has 2 differences :
    - Its underlying data structure is LinkedList and hashtable.
    - Insertion order is preserved i.e the elements will be returned in which order these are
    //inserted.
    
    Note: In general LHS is best coice in developing cache memory based appications.
    */
    public static void aboutLinkedHashSetClass()
    {
        LinkedHashSet lhs=new LinkedHashSet();
        lhs.add("A");
        lhs.add("B");
        lhs.add("C");
        lhs.add(25);
        lhs.add("D");
        lhs.add("E");
        lhs.add(50);
        lhs.add("A");
        System.out.println(lhs);
        lhs.clear();
        System.out.println(lhs);
    }
    /*
    TreeSet class :
    - The underlying data structure is balanced tree.
    - duplicate objects are not allowed.
    - Only homogenous objects are allowed otherwise we will get compile time error 
    saying :ClassCatchedException.
    - Objects are inserted according to default or customized sorting order.
    - It implements Serializzable , Cloneable but not RandomAccess.
    
    note :
    - If we depend on default sorting order then those objects must be homogenous and
    Comparable otherwise we will get CCE.
    
    The objects are said to be comaparable if the corresponding class implements Comparable 
    interface. String class and all Wrapper classes objects are Comparable as those classes
    implement Comparable interface. But StringBuffer objects are not Comparable as this class
    doesn't implements Comparable interface.
    */
    public static void aboutTreeSetClass()
    {
        TreeSet ts1=new TreeSet();
        // these elements are  Comparable & inserted according to default sorting order.
        ts1.add(10);
        ts1.add(20);
        ts1.add(30);
        ts1.add(40);
        ts1.add(50);
        System.out.println(ts1);
        
        
        TreeSet ts2=new TreeSet();
        //the following elements will lead to CCE because the following objs aren't Comparable
        //ts2.add(new StringBuffer("jkf"));
        //ts2.add(new StringBuffer("hhh"));
        //Exception in thread "main" java.lang.ClassCastException: java.lang.StringBuffer cannot be cast to java.lang.Comparable
    }
    public static void main (String[] args) {
        //SetConcepts.aboutHashSetClass();
       //SetConcepts.aboutLinkedHashSetClass();
       SetConcepts.aboutTreeSetClass();
    }
}
/*
Comparable & Comparator interface :
===================================


Comarable interface :
---------------------

- Present inside java.lang package.
- Used for default sorting order. String class, all Wrapper classes implements Comarable to provide 
default sorting order.

note:
 StringBuffer class doesn't implements Comarable interface so if we add the StringBuffer objects into
 Collection objects then we will get Exception saying : ClassCastException
*/
import java.util.*;
/*

class TreeSetDemo1
{
    public static void main(String [] args)
    {
       TreeSet ts1=new TreeSet();
       //The following elements will be inserted according to default sorting order because String 
       //objects are Comparable
       ts1.add("a");
       ts1.add("z");
       ts1.add("p");
       ts1.add("t");
       ts1.add("l");
       System.out.println(ts1);// [a, l, p, t, z]
       
       TreeSet ts2=new TreeSet();
       ts2.add(10);
       ts2.add(30);
       ts2.add(20);
       ts2.add(15);
       ts2.add(50);
       ts2.add(25);
       System.out.println(ts2);// [10, 15, 20, 25, 30, 50]
    }
}

*/
/*
Comparator :
------------
- If we don't want default natural sorting order then we can use customized sorting by using Comparator.

- Comparator interface is present inside java.util package. 

- It has 2 methods :       i- compare()     &     ii- equals() .

- If we don't want default natural sorting then our class will have to implement Comparator interface
& override the compare() method inside our class to proveide the customized sorting. Our class needn't
override the equals() method.

q: When a customized class implements Comparator interface then that class can override only compare()
method but not the equals() method. why ?

ans: Because equals() method is by default available to any class due to Object class as a parent class
of all built-in as well as customized classes.

*/

/*Wap to insert Integer objects into TreeSet where the sorting order should be descending order.*/

// For this abive question, we must have to implement Comparator and override the Compare() method.

class MyComparator implements Comparator
{
    public int compare(Object obj1, Object obj2)
    {
        Integer i1=(Integer)obj1;
        Integer i2=(Integer)obj2;
        
        return i2.compareTo(i1);
    }
}
public class TreeSetDemo2
{
    public static void main (String[] args)
    {
        MyComparator mc=new MyComparator();
        TreeSet ts1=new TreeSet(mc);
        ts1.add(10);
        ts2.add(5);
        ts1.add(35);
        ts2.add(20);
        ts1.add(45);
        ts2.add(15);
        System.out.println(ts1);
    }
}

/*Wap to insert String objects into the TreeSet where all elements should be inserted according to
reverse alphabetical order.*/
class MyComparator2 implements Comparator
{
    public int compare(Object obj1,Object obj2)
    {
        String s1=(String)obj1;
        String s2=(String)obj2;
        return s2.compareTo(s1);
    }
}
class TreeSetDemo3 
{
    public static void main (String[] args)
    {
        MyComparator2 mc=new MyComparator2();
        TreeSet ts1=new TreeSet(mc);
        ts1.add("z");
        ts1.add("t");
        ts1.add("u");
        ts1.add("h");
        ts1.add("y");
        ts1.add("t");// this element won't be added.
        ts1.add("w");
        ts1.add("d");
        System.out.println(ts1);
    }
}
/*
Wap to inset StringBuffer objects into TreeSet whwre sorting order is alphabetical order.*/


/*Note if we add StringBuffer objects as default natural sorting order then will get CCE because
StringBuffer objects aren't Comparable.*/

class MyComparator3 implements Comparator
{
    public int compare(Object obj1,Object obj2)
    {
        String s1=obj1.toString();
        String s2=obj2.toString();
        return s1.compareTo(s2);
    }
}
public class TreeSetDemo4
{
    public static void main (String[] args)
    {
        TreeSet ts=new TreeSet(new MyComparator3());
        ts.add(new StringBuffer("s"));
        ts.add(new StringBuffer("a"));
        ts.add(new StringBuffer("10"));// possible because we used toString() method inside compare().
        ts.add(new StringBuffer("t"));
        ts.add(new StringBuffer("b"));
        ts.add(new StringBuffer("u"));
        ts.add(new StringBuffer("s"));
        ts.add(new StringBuffer("p"));
        System.out.println(ts);
    }
}

/*Wap to insert all kind of String & StringBuffer objects into TreeSet where the sorting order is
increasing order & if 2 objects have same length then consoder their alphabetical order.*/

class MyComparator4 implements Comparator
{
    public int compare(Object obj1,Object obj2)
    {
       int i1=obj1.toString().length();
       int i2=obj2.toString().length();
        
       if(i1>i2) 
        return +1;
        else if(i1<i2)
        return -1;
        else
        return s1.compareTo(s2);
    }
}
class TreeSetDemo5
{
    public static void main (String[] args)
    {
        TreeSet ts=new TreeSet(new MyComparator4());
        ts.add(new StringBuffer("zzz"));
        ts.add("aaaaa");
        ts.add(new StringBuffer("yy"));
        ts.add("aa");
        ts.add(new StringBuffer("kkk"));
        ts.add("vvvv");
        System.out.println(ts);
        
        
    }
}
/*
- For our customized classes, the person who is writting the classes, is responsoble to define default
natural sorting order by implementing Comparable interface.

- The person who is using that class, if he/she doesn't need the default natural sorting order then
he/she can define customized sorting order by implementing Comparator.
*/
class Students
{
    private String name;
    int id;
    Students(String name,int id)
    {
        this.name=name;
        this.id=id;
    }
    public String getName()
    {
        return this.name;
    }
    public String toString()
    {
        return this.name+"  "+this.id;
    }
    public int compareTo(Object obj)
    {
        Students s=(Students).obj;
        int id1=this.id;
        int id2=s.id;
        if(id1<id2)
        return -1;
        else if(id1>id2)
        return +1;
        else
        return 0;
    }
}
// the following program is for default sorting order according to increasingorder of id of students .
class TreeSetDemo6
{
    public static void main (String[] args)
    {
        TreeSet ts=new TreeSet();
        Students s1=new Students("Somanath",110);
        Students s2=new Students("Bikash",105);
        Students s3=new Students("Satya",140);
        Students s4=new Students("Lokanath",112);
        Students s5=new Students("Susil",100);
        Students s6=new Students("Suraj",115);
        Students s7=new Students("Kanhu",130);
        Students s8=new Students("Ajaya",130);//this element won't be added due to duplicacy.
        ts.add(s1);
        ts.add(s2);
        ts.add(s3);
        ts.add(s4);
        ts.add(s5);
        ts.add(s6);
        ts.add(s7);
        ts.add(s8);
        System.out.println(ts);
    }
}
// the following is for customized sorting order where the elements are inserted according to
// alphabetical order of their names.
class MyComparator5 implements Comparator
{
    public int compare(Object obj1,Object obj2)
    {
        Students s1=(Students)obj1;
        Students s2=(Students)obj2;
        return s1.getName().compareTo(s2.getName());
    }
}
class TreeSetDemo7
{
    public static void main (String[] args)
    {
        TreeSet ts=new TreeSet(new MyComparator5());
        Students s1=new Students("Somanath",110);
        Students s2=new Students("Bikash",105);
        Students s3=new Students("Satya",140);
        Students s4=new Students("Lokanath",112);
        Students s5=new Students("Susil",100);
        Students s6=new Students("Suraj",115);
        Students s7=new Students("Kanhu",130);
        Students s8=new Students("Ajaya",130);//this element won't be added due to duplicacy.
        ts.add(s1);
        ts.add(s2);
        ts.add(s3);
        ts.add(s4);
        ts.add(s5);
        ts.add(s6);
        ts.add(s7);
        ts.add(s8);
        System.out.println(ts);
        
    }
}

/*
Hashtable class
---------------

- The underlying data structure is Hashtable.
- intertion order isn't preserved i.e it is based on hashcode.
- duplecate keys aren't allowed but values can be duplecated.
- Heterogenous objects are allowed both for key and values.
- null is not allowed both key and value.
- Every method present inside the Hashtable is synchronized, hence Hashtable objects are thread safe.
- Hashtable is best suitable if our frequent operation is search operation.

*/

// we can provide customized hashcode for the Hashtable objects.
import java.util.*;
class Test
{
    int counter;
    Test(int counter)
    {
        this.counter=counter;
    }
    public int hashcode()
    {
        return counter;
    }
    public String toString()
    {
        return ""+counter;
    }
}
class HashtableDemo
{
    public static void main (String[] args)
    {
        Hashtable ht=new Hashtable();
        ht.put(new Test(5),"qqqq");
        ht.put(new Test(2),"rrrr");
        ht.put(new Test(6),"ffff");
        ht.put(new Test(15),"tttt");
        ht.put(new Test(23),"ffff");
        ht.put(new Test(16),"tttt");
        //ht.put("hghfjfj","jfdjfdj");// Heterogenous elements are allowed both for key and value.
       // ht.put(null,"ffff");//null isn't allowed both for key & value.
        System.out.println(ht);
    }
}/*
/*Properties class
------------------

- This class is mainly used to get the content of a properties file through Properties object then update
that content and then store that file.

- Properties objects hold key-value pairs where both key and the value are String type.

*/
import java.util.*;
import java.io.*;
class PropertiesDemo
{
    public static void main (String[] args)
    {
        // everything i am practicing is on this online IDE.
        //because I haven't install jdk so filehandling is not possible.
        Properties p=new Properties();
        FileInputStream fis=new FileInputStream("abc.properties");
        p.load(fis);
        System.out.println(p);
        String s=p.getProperty("aaa");
        System.out.println(s);
        p.setProperty("ooo","123hhhh@999");
        FileOutputStream fos=new FileOutputStream("abc.properties");
        p.store(fos,"updated by me");
    }
}
/*
Queue interface
---------------

- If we want to represent a group of individual objects prior to processing then we should go for Queue.

- For example, before sending sms, all mobile numbers have to be stored in some data structure. The order
in which the mobile numbers are added in the same order the sms should be delivered. For this FIFO re-
quirement, Queue is the best choice.

- Usually Queue followes FIFO order but based on our requirement , we can provede our own priority order
also.

Note: LinkedList based implementation of Queue always follows FIFO order.


priorityQueue class
-------------------

- If wee want to represent a group of individual objects prior to processing according to some sorting 
order then we should go for PriorityQueue.

- The priority can default or customized.

- If we want default natural sorting order then the objects should be homogeneous and Comparable.

- If we want our own sorting order then we can use Comparator.
*/
//ex for default natural sorting 
import java.util.*;
/*
class PrioriryQueueDemo
{
    public static void main (String[] args) {
        PriorityQueue p=new PriorityQueue();
        for(int i=1;i<=10;i++)
        {
            p.offer(i);
        }
        System.out.println(p);
        System.out.println(p.poll());
        System.out.println(p);
        
    }
}
*/
//ex for customized sorting

class Mycomparator implements Comparator
{
    public int compare(Object o1,Object o2)
    {
        String s1=o1.toString();
        String s2=o2.toString();
        return s2.compareTo(s1);
    }
}
class PriorityQueueDemo2
{
    public static void main (String[] args)
    {
        PriorityQueue p=new PriorityQueue(10,new Mycomparator());
        p.offer("aaa");
        p.offer("aab");
        p.offer("ggg");
        p.offer("qqq");
        p.offer("bbb");
        p.offer("mmm");
        System.out.println(p);
    }
}
/*
Arrays class
------------

- This class is used to perform different operations on array.

-the folllowing methods are used to sort the elements of an array -
 ------------------------------------------------------------------               
                                        (1) public static void sort(primitive[] p)
                                        - This method is used to sort the primitive array according to
default sorting order.

                                        (2) public static void sort(Object[] o)
                                        - This method is used to sort the Object type array like String
array, Wrapper class object array etc accrding to default natural sorting.

                        
                                        (3) public static void sort(Object o,Comparator c)
                                        - This method is used to sort the object type array according to
customized sorting.

For searching purpose this class has the following methods :
------------------------------------------------------------
                        (1) public static int binarySearch(primitive[] p,primitive target)
                        (2) public static int binarySearch(Object[] o,Object target)
                        (3) public static int binarySearch(Object[] o,Object target,Comparator c)
                        
                        note: Before searching the elements must have to be sorted otherwise we will
                        get unexpected output.
*/
import java.util.*;

class Test implements Comparable
{
    int i;
    Test(int i)
    {
        this.i=i;
    }
    public String toString()
    {
        return "Test"+this.i;
    }
    public int compareTo(Object o)
    {
        String s1=this.toString();
        String s2=o.toString();
        return s1.compareTo(s2);
    }
}
/*
public class ArraysClassDemo
{
    class MyComparator implements Comparator
    {
        public int compare(Object o1,Object o2)
        {
            String s1=o1.toString();
            String s2=o2.toString();
            return s2.compareTo(s1);
        }
    }
    public static void main(String[] args) 
    {
        //for primitives
        int [] arr={1,34,12,6,45,11,8};
        System.out.println("Array before sorting : ");
        for(int i:arr)
        {
            System.out.print(i+" ");
        }
        System.out.println();
        Arrays.sort(arr);
        System.out.println("Array after sorting : ");
        for(int i:arr)
        {
            System.out.print(i+" ");
        }
        
        
        //for object type Array
        String [] str={"e","t","p","l","b","d","e","m"};
        System.out.println("Array before sorting : ");
        for(String s:str)
        {
            System.out.print(s+" ");
        }
        Arrays.sort(str);
        System.out.println();
        System.out.println("Array after sorting : ");
        for(String s:str)
        {
            System.out.print(s+" ");
        }
        System.out.println();
        Test [] t=new Test[5];
        int x=10;
        for(int i=0;i<=4;i++)
        {
            t[i]=new Test(x);
            x=x+10;
        }
       System.out.println("Array before sorting : ");
        for(Test tt:t)
        {
            System.out.print(tt+" ");
        }
        System.out.println();
        Arrays.sort(t);
        System.out.println("Array after default sorting : ");
        for(Test tt:t)
        {
            System.out.print(tt+" ");
        }
        
        //sorting the Test class object according to Comparator
        System.out.println();
        
        ArraysClassDemo acd=new ArraysClassDemo();
        ArraysClassDemo.MyComparator mc=acd.new MyComparator();
        Arrays.sort(t,mc);
        System.out.println("Array after sorting according to Comparator : ");
        for(Test tt:t)
        {
            System.out.print(tt+" ");
        }
    }
}
*/
class BinarySearchDemo
{
    class MyComparator implements Comparator
    {
        public int compare(Object o1,Object o2)
        {
            String s1=o1.toString();
            String s2=o2.toString();
            return s2.compareTo(s1);
        }
    }
    public static void main (String[] args)
    {
        int [] arr={12,34,8,6,35};
        System.out.println(Arrays.binarySearch(arr,12));//-5
        Arrays.sort(arr);
        System.out.println(Arrays.binarySearch(arr,12));//2
        System.out.println(Arrays.binarySearch(arr,5));//-1
        Test [] t=new Test[5];
        int x=10;
        for(int i=0;i<=4;i++)
        {
            t[i]=new Test(x);
            x=x+10;
        }
        Arrays.sort(t);
        System.out.println(Arrays.binarySearch(t,"Test30"));
        
        BinarySearchDemo bsd=new BinarySearchDemo();
        BinarySearchDemo.MyComparator mc=bsd.new MyComparator();
        Arrays.sort(t,mc);
        for(Test ttt:t)
        {
            System.out.print(ttt+" ");
        }
        System.out.println(Arrays.binarySearch(t,"Test10",mc));
        
    }
}

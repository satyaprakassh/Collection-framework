/*

COLLECTION FRAMEWORK
--------------------



Limitations of Arrays :
-----------------------

(1) Arrays Are fixed in size :
- Once we declare an array with some size, after then we can't increase or decrease
that size on requirement. So to use array, we should compulsory know the size in 
advance.

ex: int [] i=new int[5];
    i[6]=12;// error. ArrayIndexOutOfBoundsException;

(2) Can hold only homogeneous elements :
- Once we declare an array of certain type then that array can only contain the same
type of elements. If we try to put any other type of elements to that array than we 
will get compile time error.

ex: Student [] s=new Student[5];
    s[0]=new Student();// valid
    s[3]=new Integer(10);//  invalid
    s4[]="sdfs";// invalid
    
                            - But there is one exception where an array can hold
heterogeneous elements using Object class as array_type.

ex:   Object [] o=new Object[10];
        o[0]=new Student();// valid
        o[3]=new Test();// valid
        o[5]="kkkkkkk";// valid


(3) doesn't support inbuilt methods :
- Arrays hsvan't any inbuilt method support. So for every time, we have to provide 
the required logics, which may increase the complexity of the programs and decrease
the performance.

- To overcome the above mentioned issues we should go for Collection framework.
*/

class IssuesWithArrays
{
    public static void main (String[] args)
    {
        String [] arr=new String[5];
        System.out.println(arr);
        arr[4]="45";
        System.out.println(arr[4]);
        arr=new String[6];//here we creating another array but not increasing its size
        System.out.println(arr);
        System.out.println(arr[3]);
    }
}

/*

Advantages of Collection over arrays :

(1) Growable in nature:
- Collections are Growable in nature i.e based on requirement we can incease or decrease
the size.

(2) Can hold both homogeneous & heterogeneous elements:

(3) Supports inbuilts methods:
-Every Collections class is implemented based on some standard data structure. Hence
for every requirment, readymade method support is available.


-note-

- performance wise Arrays are better than Collections.
- Arrays can hold both primitives and objects but Collections can hold only objects.




Collection framework:
---------------------

- It is a framework which contains several predefined classes and interfaces which
are used to represent a group of individual objects as a single entity.



9 key interfaces of Collection framework:
-----------------------------------------

(1) Collection

(2) List

(3) Set

(4) SortedSet

(5) NavigableSet

(6) Queue

(7) Map

(8) SortedMap

(9) NavigableMap


Brief introduction of the above interfaces:
-------------------------------------------
(1) Collection interface : This interface contains the most common methods which are
applicable for any Collection object. In general, Collection interface is considered
as the root interface of Collection framework.

Difference between Collection and Collections :   Collection is an interface whereas
Collections is a class present inside java.util package.



(2) List interface : It is the child interface of Collection  interface.

-    In which circumstances should we use List : If we want to represent a group of 
individual objects as a single entity where duplicates are allowed & insertion order
must be preserved then we should go for List.

- List interface has following utility classes :
- ArrayList
- LinkedList
- Vector
- Stack


(3) Set interface:  It is the direct child interface of Collection.

-   In which circumstances should we use Set : If we want to represent a group of
individual objects as a single entity where duplicates aren't allowed and insertion
order isn't required then we should go for Set interface.

- Set has following utility classes :
-HashSet
-LinkedHashSet



(4) SortedSet interface : It is the direct child interface of Set interface.

-   In which circumstances should we use Set : If we want to represent a group of
individual objects as a single entity where duplicates aren't allowed but all objects
must be inserted according to specific sorting order then we should go for SortedSet
interface.

- It has no direct child class.


(5) NavigableSet : It is the direct child interface of SortedSet. It contans several
methods for navigable purposes.

- It has a child class :   TreeSet




Queue interface : It is the child interface of Collection .

-   In which circumstances should we use Set : If we want to represent a group of
objects prior to processing then we should go for Queue interface.

- Usually, Queue follows FIFO algorithm but based on our requirement, we can implement
our own priority order also.

ex: Before sending mails, all mail-ids should be stored in some data structure. The
order in which we add the mail-ids, in the same order messeges are sent. In such 
circumstances Queue is best choice to use.

- The following are the implementation classes :

- PriorityQueue
- BlockingQueue
- PriorityBlockingQueue
- LinkedBlockingQueue
etc etc.

-note-

- All the interfaces from (1-6) are meant for representinng a group of individual 
objects.
- If we want to represent a group of objects as key-value pairs then we should go
for Map(7-9).




(7) Map interface : Map isn't the child interface of Collection.

In which circumstances we should use Map : If we want to reprent a group of objects
as key-value pairs then we should go for Map.

- Both key & value are objects only. Duplicate keys aren't allowed but values can be
Duplicated.


- The following are the implementation classes :

- HashMap
- LinkedHashMap
- WeakHashMap
- IdentityHashMap
- Dictonary
- Hashtable
- Properties



(8) SortedMap interface :  It is the child interface of Map.

- In which circumstances we should use Map : If we want to reprent a group of objects
as key-value pairs according to some sortinng order of keys then we should go for 
Map.

-note- 

- In SortedMap, the Sirting should be based on keys but not on values.



(9)NavigableMap : It is the child interface of SortedMap. It defines several methods
for navigable purposes.

- It has a implemetation class : TreeMap 
*/
import java.util.*;
class CollectionConcepts
{
     /*properties of ArrayList:
     --------------------------
        - It is resizable ie unlike Arrays, we can increase and decrease the size of
        the list.
        - duplicate objects are allowed to be stored.
        - Insertion order is preserved.
        */
         /*constructors :
        ----------------
        (1) ArrayList al=new ArrayList() : creates an deault AL object with initial
        capacity 10. When it reaches its maximum capacity then a new object is created
        with new capacity= previous capacity*(3/2) +  1   and the previous object is
        destroyed(goes to garbage collection).
        */
        /*
        public static void ALConstrucotr1()
        {
            ArrayList al1=new ArrayList();
            System.out.println(al1.size());//o|p : 0  ,but why not showing 10 as size ?
            al1.add(10);
            System.out.println(al1.size());
            System.out.println(al1);
            al1.add("rrr");
            al1.remove(0);
            System.out.println(al1);
        }
         /*
        (2)ArrayList al=new ArrayList(int capacity) : creates an AL object with some
        initial capacity.
         *//*
         public static void ALConstrucotr2()
         {
             ArrayList al2=new ArrayList(10);
             System.out.println(al2.size());// 1
             for(int i=0;i<=9;i++)
             {
                 al2.add(i);
             }
             al2.add(20);
             al2.remove(5);
             System.out.println(al2.size());// 11
             System.out.println(al2);
          }
           /*
         (3) ArrayList al=new ArrayList(collection c) : creates an AL object for any
         Collection object ie this constructor is used for interconversion of any 
         Collection object to AL object.
         *//*
         public static void ALConstrucotr3()
         {
             Vector v1=new Vector();
             v1.addElement("zzz");
             v1.addElement("hhh");
             ArrayList al3=new ArrayList(v1);
             System.out.println(al3.size());
             System.out.println(al3);
          }
        /*Properties of LinkedList :
        ----------------------------
        - It supports double LinkedList.
        - duplicates are allowed.
        - Insertion order is preserved.
        -It implements Serializable and Cloneable interface but not RandomAccess.
        */
        /*constructors :
        (1) LinkedList ll=new LinkedList() : creates an empty LL object.
        (2) LinkedList l=new LinkedList(Collection c) : interconversion of any collection obj
        to LL object.
        *//*
        static void operateOnLL()
        {
            LinkedList l=new LinkedList();
            l.add(50);
            l.add("t");
            l.add(null);
            l.removeFirst();
            l.set(2,"k");
            System.out.println(l);
        }
        /*properties of Vector :
        ------------------------
        - resizable in nature.
        - Insertion order is preserved.
        - duplicates are allowed.
        - It implements Serializable, Cloneable and also RandomAccess interface.
        - Every method of Vactor class is synchronized. So Vactor objects are thread safe.
        */
        /*constructors:
        ---------------
        (1) Vector v=new Vector(int initial capacity) 
        (2) Vector v=new Vector(int initial capacity,int incremental_capacity) : creates a
        Vector obj with some initial capacity. When it reches its maximum capacity then its
        its capacity is increased by the provied value. If it again reaches its maximum 
        capacity then it further increases its capacity and so on.
        (3) Vector v=new Vector(collection c) : used for interconversion.
        *//*
        static void Vconstructor2()
        {
            Vector v1=new Vector(5,2);
            System.out.println(v1.capacity());
            for(int i=1;i<=5;i++)
            {
                v.add(i);
            }
            v.add("hhh");
            v.add("shs");
            v.add("mmm");
            System.out.println(v1.capacity());
        }
        /*
        Cursors of java : If we want to get objects one by one from the Collection then Cursors
        are used. There are 3 types of cursors.
        
        (1) Enumeration : Used to get the objects of Legacy Collection classes like Vector.
        
        How to create Enumeration object : by using element() method.
        syntax : public Enumeration elements()*//*
        public static void enumeration()
        {
            Vector v=new Vector();
            for(int i=10;i<=100;i++)
            {
                if(i%10==0)
                {
                    v.addElement(i);
                }
            }
            System.out.println(v);
            
            Enumeration e=v.elements();
            while(e.hasMoreElement())
            {
                Integer i=(Integer)e.nextElement();
                if(i%20==0)
                {
                    System.out.println(i+" ");
                }
            }
            System.out.println(v);
        }
        /*
        disadvantages of Enumeration : we can apply Enumeration objects only for legacy classes
        - we can get only read access , can't perform remove operations.
        
        To overcome theh above problems we should use Iteration*/
        /*(2) Iteration :  This is universal cursor object so we can apply to any Collection
        object.
        - We can perform both read & remove operations.
        
        How to get Iterator object : by using iterator() method
        syntax : public Iterator iterator()
        */
        public static void getIteratorObj()
        {
            ArrayList <String>al=new ArrayList<String>();
            al.add("a");
            al.add("b");
            al.add("c");
            al.add("d");
            Iterator i=al.iterator();
            Object obj=i.next();
            i.remove();
            System.out.println(obj);
            System.out.println(al);
        }
    public static void main (String[] args)
    
    {
        CollectionConcepts.getIteratorObj();
    }
}
